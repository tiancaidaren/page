<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <title>渠道按日汇总可视化（稳健版）</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- 必要库 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
      :root {
        --bg: #0b1020;
        --card: #121a33;
        --muted: #7881a1;
        --text: #ecf0ff;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: #0b1020;
        color: var(--text);
        font-family: ui-sans-serif, system-ui, "PingFang SC", "Microsoft YaHei", Arial;
      }
      .container {
        max-width: 80%;
        margin: 0 auto;
        padding: 24px;
      }
      .card {
        background: #121a33;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        padding: 18px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      }
      h1 {
        margin: 0 0 12px;
        font-size: 22px;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }
      .pill {
        background: #0e1430;
        border: 1px solid rgba(255, 255, 255, 0.12);
        padding: 10px;
        border-radius: 12px;
        display: flex;
        gap: 10px;
        align-items: center;
      }
      select,
      button,
      input[type="file"] {
        background: #0e1430;
        color: var(--text);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 8px;
        padding: 8px 10px;
      }
      button:hover {
        border-color: #6ea8fe;
        cursor: pointer;
      }
      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        max-height: 120px;
        overflow: auto;
        margin-top: 8px;
      }
      .legend label {
        background: #0f1639;
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        display: flex;
        gap: 6px;
        align-items: center;
      }
      .table-wrap {
        overflow: auto;
        max-height: 520px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      table {
        width: 100%;
        border-collapse: collapse;
        background: #0e1430;
        font-size: 13px;
        min-width: 760px;
      }
      tbody tr.date-alt {
        background: rgba(255, 255, 255, 0.04);
      }
      th,
      td {
        padding: 9px 10px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.07);
      }
      th {
        position: sticky;
        top: 0;
        background: #121a33;
      }
      .right {
        text-align: right;
      }
      .subtle {
        color: var(--muted);
        font-size: 12px;
        margin-top: 6px;
      }
      .spacer {
        height: 10px;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        font-size: 12px;
        color: #bfd2ff;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="card">
        <h1>渠道按日汇总 & 折线图（稳健识别渠道列）</h1>
        <div class="row">
          <div class="pill">
            <strong>上传 Excel：</strong>
            <input id="file" type="file" accept=".xlsx" />
          </div>
          <div class="pill">
            <label for="metric">指标</label>
            <select id="metric">
              <option value="当日进粉">当日进粉</option>
              <option value="当日回复">当日回复</option>
              <option value="当日回复率">当日回复率（%）</option>
              <option value="当日股民">当日股民</option>
              <option value="当日股民率">当日股民率（%）</option>
            </select>
          </div>
          <div class="pill">
            <button id="selectAll">全选渠道</button>
            <button id="clearAll">清空渠道</button>
            <button id="downloadCsv">导出汇总CSV</button>
          </div>
        </div>

        <div class="mono" id="debug"></div>

        <canvas id="chart" height="110" style="margin-top: 10px"></canvas>
        <div class="legend" id="channelFilters"></div>
        <div class="subtle">
          说明：程序自动寻找表头（含“当日进粉/当日回复/当日股民”）与“渠道列”。会排除 URL、wa.me
          链接、纯数字、过长文本等。
        </div>
      </div>

      <div class="spacer"></div>

      <div class="card">
        <h2 style="margin: 0 0 8px; font-size: 18px">汇总数据</h2>
        <div class="table-wrap">
          <table id="table"></table>
        </div>
      </div>
      <div class="spacer"></div>
      <div class="card">
        <h2 style="margin: 0 0 8px; font-size: 18px">客服汇总</h2>
        <div class="table-wrap">
          <table id="agentTable"></table>
        </div>
      </div>
    </div>

    <script>
      // ---------- 工具 & 规则 ----------
      const DIGIT_ONLY = /^\d+(\.\d+)?$/;
      const hasUrl = s => /https?:\/\//i.test(s || "") || /wa\.me/i.test(s || "");
      const hasBadChars = s => /@/.test(s || "");
      const normalizeChannelSeparators = s =>
        s.replace(/[\u3001\uff0c,;\uff1b|\uff5c+\uff0b&\ufe62\u00b7\u2022\\]/g, "/");
      const getChannelTokens = val => {
        const raw = String(val ?? "").trim();
        if (!raw) return null;
        if (hasUrl(raw) || hasBadChars(raw)) return null;
        if (raw.length > 40) return null;
        const norm = normalizeChannelSeparators(raw);
        if (/\s/.test(norm)) return null;
        const parts = norm
          .split("/")
          .map(p => p.trim())
          .filter(Boolean);
        if (!parts.length || parts.length > 3) return null;
        const cleaned = [];
        for (const part of parts) {
          if (part.length < 1 || part.length > 16) return null;
          if (DIGIT_ONLY.test(part)) return null;
          if (/[^-\w\u4e00-\u9fa5]/.test(part)) return null;
          cleaned.push(part.toLowerCase());
        }
        const uniq = Array.from(new Set(cleaned));
        uniq.sort((a, b) => a.localeCompare(b, "zh-CN"));
        return uniq;
      };
      const normalizeChannelValue = val => {
        const tokens = getChannelTokens(val);
        return tokens ? tokens.join("/") : "";
      };
      const FIELD_DATE = "日期";
      const FIELD_CHANNEL = "渠道名";
      const FIELD_AGENT = "线下接粉人";
      const AGENT_HEADER_KEYWORDS = ["线下接粉人", "接粉人", "接粉客服", "客服"];
      const AGENT_HEADER_KEYWORDS_LOWER = AGENT_HEADER_KEYWORDS.map(k => k.toLowerCase());
      const METRIC_JINFEN = "当日进粉";
      const METRIC_HUIFU = "当日回复";
      const METRIC_HUIFU_RATE = "当日回复率（%）";
      const METRIC_GUMIN = "当日股民";
      const METRIC_GUMIN_RATE = "当日股民率（%）";
      const METRIC_YOUXIAO = "有效";
      const METRIC_YOUXIAO_RATE = "有效率（%）";
      const METRIC_YIGUO = "异国";
      const METRIC_YIGUO_RATE = "异国率（%）";
      const METRIC_CHONGFEN = "重粉";
      const METRIC_CHONGFEN_RATE = "重粉率（%）";
      const METRIC_JINQUN = "进群";
      const METRIC_JINQUN_RATE = "进群率（%）";

      const METRIC_KEYS = [
        METRIC_JINFEN,
        METRIC_HUIFU,
        METRIC_HUIFU_RATE,
        METRIC_GUMIN,
        METRIC_GUMIN_RATE,
        METRIC_YOUXIAO,
        METRIC_YOUXIAO_RATE,
        METRIC_YIGUO,
        METRIC_YIGUO_RATE,
        METRIC_CHONGFEN,
        METRIC_CHONGFEN_RATE,
        METRIC_JINQUN,
        METRIC_JINQUN_RATE,
      ];
      const PERCENT_METRICS = new Set([
        METRIC_HUIFU_RATE,
        METRIC_GUMIN_RATE,
        METRIC_YOUXIAO_RATE,
        METRIC_YIGUO_RATE,
        METRIC_CHONGFEN_RATE,
        METRIC_JINQUN_RATE,
      ]);
      const isPercentMetric = key => PERCENT_METRICS.has(key) || /率/.test(String(key));
      const metricSelect = document.getElementById("metric");
      if (metricSelect) {
        metricSelect.innerHTML = METRIC_KEYS.map(key => `<option value="${key}">${key}</option>`).join("");
        metricSelect.value = METRIC_JINFEN;
      }
      const formatMetricValue = (key, value) => {
        if (value === null || value === undefined || value === "") return "-";
        const num = Number(value);
        if (!Number.isFinite(num)) return value;
        return isPercentMetric(key) ? `${num.toFixed(2)}%` : num;
      };
      const toNum = v => {
        const n = parseFloat(String(v ?? "").replace(/,/g, ""));
        return Number.isFinite(n) ? n : 0;
      };
      const pct2 = (num, den) => (den > 0 ? Math.round((num / den) * 10000) / 100 : 0); // 两位小数 %
      let sheetOrder = new Map(); // remember workbook sheet order for day grouping

      // 认为“像渠道名”的值：短、无URL、非纯数字、无特殊符号、不能是整句/长备注
      function isLikelyChannel(val) {
        return Boolean(getChannelTokens(val));
      }

      // sheet名转可排序日期
      function sheetNameToDateKey(name) {
        if (sheetOrder.has(name)) return sheetOrder.get(name);
        return Number.POSITIVE_INFINITY;
      }
      const formatDateLabel = name => {
        const label = String(name ?? "").trim();
        if (label) return label;
        const order = sheetNameToDateKey(name);
        return Number.isFinite(order) ? `Day ${order + 1}` : "";
      };

      // 找表头
      function findAgentColumnIndex(row) {
        if (!row) return -1;
        for (let c = 0; c < row.length; c++) {
          const raw = String(row[c] ?? "").trim();
          if (!raw) continue;
          const normalized = raw.replace(/\s+/g, "").toLowerCase();
          if (AGENT_HEADER_KEYWORDS_LOWER.some(keyword => normalized.includes(keyword))) {
            return c;
          }
        }
        return -1;
      }

      function findHeaderAndIndexes(rows) {
        const requiredKeys = ["当日进粉", "当日回复", "当日股民"];
        for (let r = 0; r < Math.min(rows.length, 30); r++) {
          const row = rows[r] || [];
          const joined = row.map(v => String(v ?? "")).join("|");
          if (requiredKeys.every(k => joined.includes(k))) {
            const findCol = (keywords, options = {}) => {
              const { exclude = [] } = options;
              for (let c = 0; c < row.length; c++) {
                const text = String(row[c] ?? "");
                if (!text) continue;
                if (exclude.some(ex => text.includes(ex))) continue;
                if (keywords.some(k => text.includes(k))) return c;
              }
              return -1;
            };
            const agentCol = findAgentColumnIndex(row);
            return {
              headerRow: r,
              colAgent: agentCol,
              colJ: findCol(["当日进粉", "进粉"], { exclude: ["率"] }),
              colH: findCol(["当日回复", "回复"], { exclude: ["率"] }),
              colG: findCol(["当日股民", "股民"], { exclude: ["率"] }),
              colYouxiao: findCol(["当日有效", "有效"], { exclude: ["率"] }),
              colYiguo: findCol(["当日异国", "异国"], { exclude: ["率"] }),
              colChongfen: findCol(["当日重粉", "重粉"], { exclude: ["率"] }),
              colJinqun: findCol(["当日进群", "进群"], { exclude: ["率"] }),
            };
          }
        }
        const fb = rows[1] || [];
        const fallbackFindCol = (keywords, options = {}) => {
          const { exclude = [] } = options;
          for (let c = 0; c < fb.length; c++) {
            const text = String(fb[c] ?? "");
            if (!text) continue;
            if (exclude.some(ex => text.includes(ex))) continue;
            if (keywords.some(k => text.includes(k))) return c;
          }
          return -1;
        };
        return {
          headerRow: 1,
          colAgent: findAgentColumnIndex(fb),
          colJ: fallbackFindCol(["当日进粉", "进粉"], { exclude: ["率"] }),
          colH: fallbackFindCol(["当日回复", "回复"], { exclude: ["率"] }),
          colG: fallbackFindCol(["当日股民", "股民"], { exclude: ["率"] }),
          colYouxiao: fallbackFindCol(["当日有效", "有效"], { exclude: ["率"] }),
          colYiguo: fallbackFindCol(["当日异国", "异国"], { exclude: ["率"] }),
          colChongfen: fallbackFindCol(["当日重粉", "重粉"], { exclude: ["率"] }),
          colJinqun: fallbackFindCol(["当日进群", "进群"], { exclude: ["率"] }),
        };
      }

      // 改进版：识别“渠道列”
      function guessChannelColumn(rows, headerRow, sheetName) {
        const dataRows = rows.slice(headerRow + 1);
        const columns = Math.max(...rows.map(r => (r || []).length));
        const debug = [];

        if (String(sheetName) === "1025") {
          const known = ["jinx", "aj", "bai", "tt", "maiya", "xm", "xigua", "xg"];
          for (let c = 0; c < columns; c++) {
            const sample = dataRows.map(r => String((r || [])[c] ?? "").trim()).filter(Boolean);
            const hit = sample.filter(
              s => isLikelyChannel(s) && known.some(k => new RegExp(`\\b${k}\\b`, "i").test(s))
            ).length;
            if (hit >= 5) {
              debug.push(`sheet 1025 shortcut -> col ${c} (hit=${hit})`);
              setDebug(debug);
              return c;
            }
          }
        }

        let bestCol = -1;
        let bestScore = -1;
        for (let c = columns - 1; c >= 0; c--) {
          const raw = dataRows.map(r => String((r || [])[c] ?? "").trim());
          if (raw.every(v => !v)) continue;

          const nonEmpty = raw.filter(Boolean);
          const urlRatio = nonEmpty.filter(hasUrl).length / nonEmpty.length;
          if (urlRatio > 0.05) {
            debug.push(`col ${c} url-heavy ${(urlRatio * 100).toFixed(1)}%`);
            continue;
          }

          const digitHeavy =
            nonEmpty.filter(v => DIGIT_ONLY.test(normalizeChannelSeparators(v))).length / nonEmpty.length;
          if (digitHeavy > 0.6) {
            debug.push(`col ${c} numeric ${(digitHeavy * 100).toFixed(1)}%`);
            continue;
          }

          const goodVals = nonEmpty.filter(isLikelyChannel);
          if (!goodVals.length) {
            debug.push(`col ${c} no channel-like values`);
            continue;
          }

          const parts = goodVals.flatMap(v => getChannelTokens(v) || []);
          const uniqParts = new Set(parts);
          const dupRatio = parts.length ? 1 - uniqParts.size / parts.length : 0;
          const channelishRatio = goodVals.length / nonEmpty.length;
          const score = dupRatio * 2.2 + channelishRatio * 1.6 + (1 - urlRatio) * 0.6 + (1 - digitHeavy) * 0.4;

          if (score > bestScore) {
            bestScore = score;
            bestCol = c;
          }
        }

        debug.push(`pick ${bestCol} score=${bestScore.toFixed(3)}`);
        setDebug(debug);
        return bestCol;
      }

      function setDebug(lines) {
        const el = document.getElementById("debug");
        el.textContent = lines.join(" | ");
      }

      // 聚合工作簿
      function aggregateWorkbook(wb) {
        const sheetNames = wb.SheetNames || [];
        const result = [];
        const rawByDay = {};
        const rawAgentByDay = {};
        sheetOrder = new Map(sheetNames.map((name, idx) => [name, idx]));

        sheetNames.forEach(name => {
          const ws = wb.Sheets[name];
          const rows = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null, blankrows: false });
          if (!rows || rows.length < 3) return;

          const meta = findHeaderAndIndexes(rows);
          const chCol = guessChannelColumn(rows, meta.headerRow, name);
          if (chCol < 0 || meta.colJ < 0 || meta.colH < 0 || meta.colG < 0) return;

          const agentCol = meta.colAgent;

          const dayKey = name;
          rawByDay[dayKey] = rawByDay[dayKey] || {};
          rawAgentByDay[dayKey] = rawAgentByDay[dayKey] || {};

          for (let r = meta.headerRow + 1; r < rows.length; r++) {
            const row = rows[r] || [];
            const rawVal = row[chCol];
            const channel = normalizeChannelValue(rawVal);
            if (!channel) continue; // 值级过滤

            const jinfen = toNum(row[meta.colJ]);
            const huifu = toNum(row[meta.colH]);
            const gumin = toNum(row[meta.colG]);
            const youxiao = meta.colYouxiao >= 0 ? toNum(row[meta.colYouxiao]) : 0;
            const yiguo = meta.colYiguo >= 0 ? toNum(row[meta.colYiguo]) : 0;
            const chongfen = meta.colChongfen >= 0 ? toNum(row[meta.colChongfen]) : 0;
            const jinqun = meta.colJinqun >= 0 ? toNum(row[meta.colJinqun]) : 0;

            const agentName = agentCol >= 0 ? normalizeChannelValue(row[agentCol]) : "";

            if (!rawByDay[dayKey][channel]) {
              rawByDay[dayKey][channel] = {
                [METRIC_JINFEN]: 0,
                [METRIC_HUIFU]: 0,
                [METRIC_GUMIN]: 0,
                [METRIC_YOUXIAO]: 0,
                [METRIC_YIGUO]: 0,
                [METRIC_CHONGFEN]: 0,
                [METRIC_JINQUN]: 0,
              };
            }
            const bucket = rawByDay[dayKey][channel];
            bucket[METRIC_JINFEN] += jinfen;
            bucket[METRIC_HUIFU] += huifu;
            bucket[METRIC_GUMIN] += gumin;
            bucket[METRIC_YOUXIAO] += youxiao;
            bucket[METRIC_YIGUO] += yiguo;
            bucket[METRIC_CHONGFEN] += chongfen;
            bucket[METRIC_JINQUN] += jinqun;
            if (agentName) {
              if (!rawAgentByDay[dayKey][agentName]) {
                rawAgentByDay[dayKey][agentName] = {
                  [METRIC_JINFEN]: 0,
                  [METRIC_HUIFU]: 0,
                  [METRIC_GUMIN]: 0,
                  [METRIC_YOUXIAO]: 0,
                  [METRIC_YIGUO]: 0,
                  [METRIC_CHONGFEN]: 0,
                  [METRIC_JINQUN]: 0,
                };
              }
              const agentBucket = rawAgentByDay[dayKey][agentName];
              agentBucket[METRIC_JINFEN] += jinfen;
              agentBucket[METRIC_HUIFU] += huifu;
              agentBucket[METRIC_GUMIN] += gumin;
              agentBucket[METRIC_YOUXIAO] += youxiao;
              agentBucket[METRIC_YIGUO] += yiguo;
              agentBucket[METRIC_CHONGFEN] += chongfen;
              agentBucket[METRIC_JINQUN] += jinqun;
            }
          }
        });

        Object.keys(rawByDay).forEach(day => {
          Object.keys(rawByDay[day]).forEach(ch => {
            const o = rawByDay[day][ch];
            const total = o[METRIC_JINFEN];
            result.push({
              [FIELD_DATE]: day,
              [FIELD_CHANNEL]: ch,
              [METRIC_JINFEN]: o[METRIC_JINFEN],
              [METRIC_HUIFU]: o[METRIC_HUIFU],
              [METRIC_HUIFU_RATE]: pct2(o[METRIC_HUIFU], total),
              [METRIC_GUMIN]: o[METRIC_GUMIN],
              [METRIC_GUMIN_RATE]: pct2(o[METRIC_GUMIN], total),
              [METRIC_YOUXIAO]: o[METRIC_YOUXIAO],
              [METRIC_YOUXIAO_RATE]: pct2(o[METRIC_YOUXIAO], total),
              [METRIC_YIGUO]: o[METRIC_YIGUO],
              [METRIC_YIGUO_RATE]: pct2(o[METRIC_YIGUO], total),
              [METRIC_CHONGFEN]: o[METRIC_CHONGFEN],
              [METRIC_CHONGFEN_RATE]: pct2(o[METRIC_CHONGFEN], total),
              [METRIC_JINQUN]: o[METRIC_JINQUN],
              [METRIC_JINQUN_RATE]: pct2(o[METRIC_JINQUN], total),
            });
          });
        });

        const agentResult = [];
        Object.keys(rawAgentByDay).forEach(day => {
          Object.keys(rawAgentByDay[day]).forEach(agent => {
            const o = rawAgentByDay[day][agent];
            const total = o[METRIC_JINFEN];
            agentResult.push({
              [FIELD_DATE]: day,
              [FIELD_AGENT]: agent,
              [METRIC_JINFEN]: o[METRIC_JINFEN],
              [METRIC_HUIFU]: o[METRIC_HUIFU],
              [METRIC_HUIFU_RATE]: pct2(o[METRIC_HUIFU], total),
              [METRIC_GUMIN]: o[METRIC_GUMIN],
              [METRIC_GUMIN_RATE]: pct2(o[METRIC_GUMIN], total),
              [METRIC_YOUXIAO]: o[METRIC_YOUXIAO],
              [METRIC_YOUXIAO_RATE]: pct2(o[METRIC_YOUXIAO], total),
              [METRIC_YIGUO]: o[METRIC_YIGUO],
              [METRIC_YIGUO_RATE]: pct2(o[METRIC_YIGUO], total),
              [METRIC_CHONGFEN]: o[METRIC_CHONGFEN],
              [METRIC_CHONGFEN_RATE]: pct2(o[METRIC_CHONGFEN], total),
              [METRIC_JINQUN]: o[METRIC_JINQUN],
              [METRIC_JINQUN_RATE]: pct2(o[METRIC_JINQUN], total),
            });
          });
        });

        result.sort((a, b) => {
          const da = sheetNameToDateKey(b[FIELD_DATE]) - sheetNameToDateKey(a[FIELD_DATE]);
          if (da !== 0) return da;
          return a[FIELD_CHANNEL].localeCompare(b[FIELD_CHANNEL], "zh-CN");
        });
        agentResult.sort((a, b) => {
          const da = sheetNameToDateKey(b[FIELD_DATE]) - sheetNameToDateKey(a[FIELD_DATE]);
          if (da !== 0) return da;
          return a[FIELD_AGENT].localeCompare(b[FIELD_AGENT], "zh-CN");
        });
        return { channel: result, agent: agentResult };
      }

      // ------- 渲染：图 + 过滤 + 表 -------
      let globalData = [];
      let agentData = [];
      let chart,
        channelsAll = new Set();

      function rebuildChannelFilters() {
        const box = document.getElementById("channelFilters");
        box.innerHTML = "";
        channelsAll = new Set(globalData.map(d => d[FIELD_CHANNEL]));
        [...channelsAll]
          .sort((a, b) => a.localeCompare(b, "zh-CN"))
          .forEach((ch, i) => {
            const id = "ch_" + i;
            const lab = document.createElement("label");
            lab.innerHTML = `<input type="checkbox" id="${id}" data-ch="${ch}" checked> ${ch}`;
            box.appendChild(lab);
            lab.querySelector("input").addEventListener("change", drawChart);
          });
      }
      function getSelectedChannels() {
        return Array.from(document.querySelectorAll("#channelFilters input[type=checkbox]:checked")).map(x =>
          x.getAttribute("data-ch")
        );
      }

      function drawChart() {
        if (!globalData.length) return;
        const metric = document.getElementById("metric").value;
        const channels = getSelectedChannels();

        const days = [...new Set(globalData.map(d => d[FIELD_DATE]))].sort(
          (a, b) => sheetNameToDateKey(a) - sheetNameToDateKey(b)
        );
        const datasets = channels.map(ch => {
          const series = days.map(day => {
            const row = globalData.find(r => r[FIELD_DATE] === day && r[FIELD_CHANNEL] === ch);
            return row ? row[metric] : 0;
          });
          return { label: ch, data: series };
        });

        const ctx = document.getElementById("chart").getContext("2d");
        if (chart) chart.destroy();
        chart = new Chart(ctx, {
          type: "line",
          data: {
            labels: days.map(d => `${formatDateLabel(d)}`),
            datasets: datasets.map(ds => ({
              label: ds.label,
              data: ds.data,
              pointRadius: 2.5,
              tension: 0.25,
            })),
          },
          options: {
            responsive: true,
            interaction: { mode: "nearest", intersect: false },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  callback: value =>
                    isPercentMetric(metric) && Number.isFinite(Number(value)) ? `${Number(value).toFixed(2)}%` : value,
                },
                title: { display: true, text: metric },
              },
              x: { title: { display: true, text: "日期" } },
            },
            plugins: {
              legend: { position: "top", labels: { usePointStyle: true } },
              tooltip: {
                callbacks: {
                  title: items => {
                    if (!items.length) return "";
                    const idx = items[0].dataIndex;
                    const day = days[idx];
                    const dateLabel = formatDateLabel(day);
                    return [`${dateLabel}`, items[0].dataset.label];
                  },
                  label: ctx => `${metric}: ${formatMetricValue(metric, ctx.parsed.y)}`,
                  afterBody: items => {
                    if (!items.length) return [];
                    const idx = items[0].dataIndex;
                    const day = days[idx];
                    const channel = items[0].dataset.label;
                    const record = globalData.find(r => r[FIELD_DATE] === day && r[FIELD_CHANNEL] === channel);
                    if (!record) return [];
                    return METRIC_KEYS.filter(key => key !== metric).map(
                      key => `${key}: ${formatMetricValue(key, record[key])}`
                    );
                  },
                },
              },
            },
          },
        });
      }

      function renderSummaryTable(tableId, data, secondKey) {
        const tbl = document.getElementById(tableId);
        if (!tbl) return;
        if (!data.length) {
          tbl.innerHTML = "";
          return;
        }
        const metricHeaders = METRIC_KEYS.map(key => `<th class="right">${key}</th>`).join("");
        const head = `<thead><tr><th>${FIELD_DATE}</th><th>${secondKey}</th>${metricHeaders}</tr></thead>`;
        let lastDay = null;
        let useAlt = false;
        const bodyRows = [];
        data.forEach(r => {
          if (r[FIELD_DATE] !== lastDay) {
            useAlt = !useAlt;
            lastDay = r[FIELD_DATE];
          }
          const rowClass = useAlt ? "date-alt" : "";
          const metricCells = METRIC_KEYS.map(key => `<td class="right">${formatMetricValue(key, r[key])}</td>`).join("");
          bodyRows.push(`
      <tr${rowClass ? ` class="${rowClass}"` : ""}>
        <td>${formatDateLabel(r[FIELD_DATE])}</td>
        <td>${r[secondKey]}</td>
        ${metricCells}
      </tr>`);
        });
        tbl.innerHTML = head + `<tbody>${bodyRows.join("")}</tbody>`;
      }

      function renderTable() {
        renderSummaryTable("table", globalData, FIELD_CHANNEL);
      }

      function renderAgentTable() {
        renderSummaryTable("agentTable", agentData, FIELD_AGENT);
      }

function exportCsv() {
        if (!globalData.length) return;
        const header = [FIELD_DATE, FIELD_CHANNEL, ...METRIC_KEYS];
        const lines = [header.join(",")];
        globalData.forEach(r => {
          const row = [
            formatDateLabel(r[FIELD_DATE]),
            `"${(r[FIELD_CHANNEL] || "").replace(/"/g, '""')}"`,
            ...METRIC_KEYS.map(key => {
              const value = r[key];
              if (value === null || value === undefined || value === "") return "";
              if (isPercentMetric(key)) return Number(value).toFixed(2);
              return value;
            }),
          ];
          lines.push(row.join(","));
        });
        const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "每日渠道汇总.csv";
        a.click();
      }

      // 事件
      document.getElementById("file").addEventListener("change", async e => {
        const f = e.target.files?.[0];
        if (!f) return;
        const buf = await f.arrayBuffer();
        const wb = XLSX.read(buf, { type: "array" });
        const aggregated = aggregateWorkbook(wb);
        // 若误检风险仍高，可考虑：过滤出出现频次>=2次的渠道名
        // const counts = aggregated.channel.reduce((m,d)=> (m[d[FIELD_CHANNEL]]=(m[d[FIELD_CHANNEL]]||0)+1, m), {});
        // globalData = aggregated.channel.filter(d=> counts[d[FIELD_CHANNEL]] >= 2);
        globalData = aggregated.channel;
        agentData = aggregated.agent;
        rebuildChannelFilters();
        renderTable();
        renderAgentTable();
        drawChart();
      });

      document.getElementById("metric").addEventListener("change", drawChart);
      document.getElementById("selectAll").addEventListener("click", () => {
        document.querySelectorAll("#channelFilters input[type=checkbox]").forEach(c => (c.checked = true));
        drawChart();
      });
      document.getElementById("clearAll").addEventListener("click", () => {
        document.querySelectorAll("#channelFilters input[type=checkbox]").forEach(c => (c.checked = false));
        drawChart();
      });
      document.getElementById("downloadCsv").addEventListener("click", exportCsv);
    </script>
  </body>
</html>
